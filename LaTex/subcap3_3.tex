\lstnewenvironment{Code03_03}[1][]{\lstset{basicstyle=\small\ttfamily, columns=fullflexible,framexrightmargin=+.1\textwidth, keywordstyle=\color{red}\bfseries, commentstyle=\color{blue},language=C++, basicstyle=\small, numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=5pt, frame=shadowbox, #1}}{}

\chapter{Classi per la gestione dell'intersezione}

Le fratture con cui lavoriamo sono poste in uno spazio 1D e hanno un unico punto in comune nel caso di una \textit{Bifurcation}. Ponendosi in uno spazio 2D la regione in comune Ã¨ invece un triangolo. Il primo caso approssima in maniera troppo brutale la situazione reale, mentre il secondo \`{e} pi\`{u} ricco di informazioni e ci permette di avere valori pi\`{u} consistenti.\\
Per avere dei risultati maggiormente significativi instauriamo dunque un legame fra questi due mondi con le condizioni da rispettare nel punto di intersezione, meglio dette condizioni d'interfaccia.\\
Nel caso 2D le fratture hanno uno spessore e possiamo delimitare un triangolo di intersezione unendo i punti di incontro dei loro bordi. \\
\begin{figure}[htbp]
\includegraphics[width=1\textwidth]{img/TriangoloBiforcazione.eps}
\caption{Struttura della biforcazione 2D}\label{Biforcazione}
\end{figure}
Presi \textbf{N} il vettore delle normali ai lati del triangolo, \textbf{$K_{I}$} la matrice di permeabilit\`{a} all'intersezione e una costante \textit{t} possiamo definire:
\begin{center}
	$ S = \textit{t}diag( \textbf{N}$ \textbf{$K_{I}$} $ \textbf{N}^{T} ) $
\end{center}
Definite ora \textbf{C} matrice dei vettori che uniscono il baricentro, punto C, del triangolo con il punto medio  di ogni lato e \textbf{$P_{c}$} matrice di proiezione sullo spazio nullo della matrice di base per \textbf{C}, possiamo trovare la matrice di trasmissibilit\`{a}:
\begin{center}
	$ T = \frac{1}{\textbf{I}}( \textbf{N}$ \textbf{$K_{I}$} $ \textbf{N}^{T} ) + $\textbf{$P_{c}$} $\textbf{S}$\textbf{$P_{c}$}
\end{center}
%\textbf{u} = \left\lbrace \u_{0}, \u_{1}, \u_{2} \right\rbrace
%$\textbf{\pi} = \left\lbrace \pi_{0}, \pi_{1}, \pi_{2} \right\rbrace $
Le variabili con cui ci troviamo a lavorare sono:
	\begin{enumerate}
	\item[-] \textbf{u} : vettore dei flussi
	\item[-] $p_{I}$ :  pressione nel punto di intersezione delle assi delle tre fratture;
	\item[-] \textbf{$\pi$}: vettore delle pressioni nel punto di incontro fra l'asse della frattura i-esima con un lato del triangolo;
	\end{enumerate} 
e le condizioni che dobbiamo porre all'intersezione sono:
\begin{center}			
	$\left \{
		\begin{array}{l}	
	 		\textbf{u} - p_{I}T\textbf{1}_{3}+T\Pi=0  \\ \\
     	 	\sum_{k=0}^2 u_{k} = p_{I} - \pi  \\
		\end{array}
	\right.$
\end{center}

Queste sono le condizioni d'interfaccia che verranno imposte nel punto di intersezione delle fratture.

\section{Classe \texttt{MatrixBifurcationHandler}}
La class \texttt{MatrixBifurcationHandler} contiene le matrici associate a una biforcazione e implementa i metodi per calcolarle. 
%Inclusa la matrice $T$, di vitale importanza per l'imposizione delle condizioni di interfaccia del nostro problema.
I campi fondamentali della classe sono:
	\begin{enumerate}
	\item[-] \texttt{M\_intersection}: di tipo Intersection, contiene tutte le informazioni base per poter ricavare le matrici;
	\item[-] \texttt{M\_T}: matrice T di vitale importanza per l'imposizione delle condizioni di interfaccia.
	\end{enumerate} 
\begin{Code03_03}[caption={Classe \texttt{Intersection}}]
class MatrixBifurcationHandler
{
 public:
	MatrixBifurcationHandler( const GetPot& dataFile,
				const std::string& section = "mediumData/",
				const std::string& subsection = "darcy/");
	
	void setMatrices ( FracturePtrContainer_Type& fractures );
	
	[ ... ]
	
	void computeT( scalar_type t=6.0 );

	[ ... ]

 private:

	Matrix2d M_K;
	Intersection_Type M_intersection;
	Matrix32 M_N;
	Matrix32 M_C;
	Matrix32 M_Qc;
	Matrix3d M_Pc;
	Matrix3d M_T;
};
\end{Code03_03}

\section{Classe \texttt{Intersection}}

La class \texttt{Intersection}, definita in \texttt{TriangleHandler.h}, contiene tutte le informazioni relative ad una biforcazione in uno spazio 2D necessarie per il calcolo delle matrici associate al triangolo di intersezione.
I campi fondamentali della classe sono:
	\begin{enumerate}
	\item[-] \texttt{M\_intersection}: di tipo PointData, rappresenta il punto di intersezione;
	\item[-] \texttt{M\_tangents}: vettore contenente le tangenti alle fratture coinvolte;
	\item[-] \texttt{M\_normals}: vettore contenente le normali alle fratture coinvolte;
	\item[-] \texttt{M\_intersectionTriangle}:di tipo TriangleData, rappresenta il triangolo di intersezione, i cui vertici sono i punti d'incontro dei bordi delle fratture.
	\end{enumerate} 

\begin{Code03_03}[caption={Classe \texttt{Intersection}}]
class Intersection
{
 public:
	[ ... ]
	
	void setIntersection( FracturePtrContainer_Type& M_FracturesSet );
	
	[ ... ]
 private:
	
	[ ... ]	
	
	PointData M_intersection;
	
	Vector2d M_tangents [ 3 ];
	Vector2d M_normals [ 3 ];
	
	TriangleData M_intersectionTriangle;
};	
\end{Code03_03}

\section{Classe \texttt{PointData} e Classe \texttt{TriangleData}}

Vengono utilizzate le classe \texttt{Matrix} e \texttt{Vector} della libreria \texttt{Eigen}.
Ci poniamo ora in uno spazio 2D.\\
La classe \texttt{PointData} ci permette di definire un punto e di poterlo manipolare con le operazioni di somma, differenza e prodotto.\\
La classe \texttt{TriangleData} ci permette di definire un triangolo e di calcolarne l'area. Inoltre sono stati implementati i metodi necessari per la costruzione del triangolo di intersezione.
