\hypertarget{namespacegetfem}{\section{Riferimenti per il namespace getfem}
\label{namespacegetfem}\index{getfem@{getfem}}
}


\hyperlink{XFEMOperators_8h}{X\-F\-E\-M\-Operators.\-h}.  


\subsection*{Composti}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classgetfem_1_1level__set__unit__normal}{level\-\_\-set\-\_\-unit\-\_\-normal}
\end{DoxyCompactItemize}
\subsection*{Funzioni}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{namespacegetfem_aba6f1b4f1d395aae3d96071cad4953a2}{darcy\-\_\-\-A11\-F} (\hyperlink{Core_8h_a87137a9501b38c724ac80bc955164bb7}{sparse\-Matrix\-Ptr\-\_\-\-Type} \&M, const \hyperlink{FractureHandler_8h_af23fb7a30aaff864bd42587af4f1e78a}{Fracture\-Handler\-Ptr\-\_\-\-Type} \&fracture, const scalar\-\_\-type \&gamma\-U, const \hyperlink{Core_8h_a4e75b5863535ba1dd79942de2846eff0}{scalar\-Vector\-\_\-\-Type} \&inv\-K\-Tangential\-Interpolated, const \hyperlink{Core_8h_a83c51913d041a5001e8683434c09857f}{size\-Vector\-\_\-\-Type} \&Ext\-Boundary, const size\-\_\-type \&uncut\-Region\-Flag)
\item 
void \hyperlink{namespacegetfem_a9b6ded8fe1019aa04e66d2047d0f29dd}{darcy\-\_\-\-A11\-F\-\_\-\-Cross} (\hyperlink{Core_8h_a87137a9501b38c724ac80bc955164bb7}{sparse\-Matrix\-Ptr\-\_\-\-Type} \&M, const \hyperlink{FractureHandler_8h_af23fb7a30aaff864bd42587af4f1e78a}{Fracture\-Handler\-Ptr\-\_\-\-Type} \&fracture, const \hyperlink{Core_8h_a4e75b5863535ba1dd79942de2846eff0}{scalar\-Vector\-\_\-\-Type} \&inv\-K\-Tangential\-Interpolated, const \hyperlink{FractureHandler_8h_af23fb7a30aaff864bd42587af4f1e78a}{Fracture\-Handler\-Ptr\-\_\-\-Type} \&other\-Fracture, const size\-\_\-type \&cut\-Region\-Flag)
\item 
void \hyperlink{namespacegetfem_ab62aa98cfcf55810e1518906202cbedc}{darcy\-\_\-\-A12\-F} (\hyperlink{Core_8h_a87137a9501b38c724ac80bc955164bb7}{sparse\-Matrix\-Ptr\-\_\-\-Type} \&M, const \hyperlink{FractureHandler_8h_af23fb7a30aaff864bd42587af4f1e78a}{Fracture\-Handler\-Ptr\-\_\-\-Type} \&fracture, const size\-\_\-type \&uncut\-Region\-Flag)
\item 
void \hyperlink{namespacegetfem_a88df6c0cb0765d5ab0fae27679cd30f4}{darcy\-\_\-\-A12\-F\-\_\-\-Cross} (\hyperlink{Core_8h_a87137a9501b38c724ac80bc955164bb7}{sparse\-Matrix\-Ptr\-\_\-\-Type} \&M, const \hyperlink{FractureHandler_8h_af23fb7a30aaff864bd42587af4f1e78a}{Fracture\-Handler\-Ptr\-\_\-\-Type} \&fracture, const \hyperlink{FractureHandler_8h_af23fb7a30aaff864bd42587af4f1e78a}{Fracture\-Handler\-Ptr\-\_\-\-Type} \&other\-Fracture, const size\-\_\-type \&cut\-Region\-Flag)
\item 
void \hyperlink{namespacegetfem_ad6e90b309c01f6b4fc91c9369cba376a}{darcy\-\_\-data\-F} (\hyperlink{Core_8h_ab09b6fa3c23db1b8c60456f8690c44a7}{scalar\-Vector\-Ptr\-\_\-\-Type} \&Bstress, \hyperlink{Core_8h_ab09b6fa3c23db1b8c60456f8690c44a7}{scalar\-Vector\-Ptr\-\_\-\-Type} \&Bvel, const \hyperlink{BCHandler_8h_aa175884cb453788647f17f2230a2a762}{B\-C\-Handler\-Ptr\-\_\-\-Type} \&bc\-Handler, const \hyperlink{FractureHandler_8h_af23fb7a30aaff864bd42587af4f1e78a}{Fracture\-Handler\-Ptr\-\_\-\-Type} \&fracture, const scalar\-\_\-type \&gamma\-U, const scalar\-\_\-type \&inv\-K, const \hyperlink{Core_8h_ab09b6fa3c23db1b8c60456f8690c44a7}{scalar\-Vector\-Ptr\-\_\-\-Type} \&Pneumann, const \hyperlink{Core_8h_ab09b6fa3c23db1b8c60456f8690c44a7}{scalar\-Vector\-Ptr\-\_\-\-Type} \&v\-\_\-diri)
\item 
void \hyperlink{namespacegetfem_ac08fe08fb325eede94ffe4968b7980de}{assembling\-\_\-\-Source\-\_\-\-Boundary\-F} (\hyperlink{Core_8h_ab09b6fa3c23db1b8c60456f8690c44a7}{scalar\-Vector\-Ptr\-\_\-\-Type} \&D, const \hyperlink{Core_8h_ab09b6fa3c23db1b8c60456f8690c44a7}{scalar\-Vector\-Ptr\-\_\-\-Type} \&source, const \hyperlink{FractureHandler_8h_af23fb7a30aaff864bd42587af4f1e78a}{Fracture\-Handler\-Ptr\-\_\-\-Type} \&fracture, const size\-\_\-type \&uncut\-Region\-Flag)
\item 
void \hyperlink{namespacegetfem_a5efeefe94dfb5427c3ecf63d0b342c57}{assembling\-\_\-\-Source\-F} (\hyperlink{Core_8h_ab09b6fa3c23db1b8c60456f8690c44a7}{scalar\-Vector\-Ptr\-\_\-\-Type} \&D, const \hyperlink{Core_8h_ab09b6fa3c23db1b8c60456f8690c44a7}{scalar\-Vector\-Ptr\-\_\-\-Type} \&source, const \hyperlink{FractureHandler_8h_af23fb7a30aaff864bd42587af4f1e78a}{Fracture\-Handler\-Ptr\-\_\-\-Type} \&fracture, const \hyperlink{FractureHandler_8h_af23fb7a30aaff864bd42587af4f1e78a}{Fracture\-Handler\-Ptr\-\_\-\-Type} \&other\-Fracture, const size\-\_\-type \&cut\-Region\-Flag)
\item 
void \hyperlink{namespacegetfem_a9a0b9f7498668cda8b547b10ac914a34}{couple\-Fractures} (\hyperlink{Core_8h_a87137a9501b38c724ac80bc955164bb7}{sparse\-Matrix\-Ptr\-\_\-\-Type} \&M, const \hyperlink{FracturesSet_8h_ac29a2a91d3af77fb459980a7db47f420}{Fractures\-Set\-Ptr\-\_\-\-Type} \&fractures)
\item 
void \hyperlink{namespacegetfem_acc74b86734c3814042e614d015f23876}{velocity\-Jump\-\_\-\-Cross} (\hyperlink{Core_8h_a87137a9501b38c724ac80bc955164bb7}{sparse\-Matrix\-Ptr\-\_\-\-Type} \&M, const \hyperlink{FractureHandler_8h_af23fb7a30aaff864bd42587af4f1e78a}{Fracture\-Handler\-Ptr\-\_\-\-Type} \&fracture, const \hyperlink{FractureHandler_8h_af23fb7a30aaff864bd42587af4f1e78a}{Fracture\-Handler\-Ptr\-\_\-\-Type} \&other\-Fracture, const size\-\_\-type \&convex)
\item 
void \hyperlink{namespacegetfem_a41dedc9759949101293821b324cf5ac6}{velocity\-Jump\-\_\-\-Bifurcation} (\hyperlink{Core_8h_a87137a9501b38c724ac80bc955164bb7}{sparse\-Matrix\-Ptr\-\_\-\-Type} \&M, const \hyperlink{FractureHandler_8h_af23fb7a30aaff864bd42587af4f1e78a}{Fracture\-Handler\-Ptr\-\_\-\-Type} \&fracture, const \hyperlink{FractureHandler_8h_af23fb7a30aaff864bd42587af4f1e78a}{Fracture\-Handler\-Ptr\-\_\-\-Type} \&other\-Fracture, const size\-\_\-type \&convex)
\end{DoxyCompactItemize}


\subsection{Descrizione dettagliata}
\hyperlink{XFEMOperators_8h}{X\-F\-E\-M\-Operators.\-h}. \hyperlink{XFEMOperators_8cc}{X\-F\-E\-M\-Operators.\-cc}.

Darcy bilinear and linear forms.

R\-E\-M\-E\-M\-B\-E\-R\-: the matrix corresponding to a(u,v) is Aij = a(, ) 

\subsection{Documentazione delle funzioni}
\hypertarget{namespacegetfem_ac08fe08fb325eede94ffe4968b7980de}{\index{getfem@{getfem}!assembling\-\_\-\-Source\-\_\-\-Boundary\-F@{assembling\-\_\-\-Source\-\_\-\-Boundary\-F}}
\index{assembling\-\_\-\-Source\-\_\-\-Boundary\-F@{assembling\-\_\-\-Source\-\_\-\-Boundary\-F}!getfem@{getfem}}
\subsubsection[{assembling\-\_\-\-Source\-\_\-\-Boundary\-F}]{\setlength{\rightskip}{0pt plus 5cm}void getfem\-::assembling\-\_\-\-Source\-\_\-\-Boundary\-F (
\begin{DoxyParamCaption}
\item[{{\bf scalar\-Vector\-Ptr\-\_\-\-Type} \&}]{D, }
\item[{const {\bf scalar\-Vector\-Ptr\-\_\-\-Type} \&}]{source, }
\item[{const {\bf Fracture\-Handler\-Ptr\-\_\-\-Type} \&}]{fracture, }
\item[{const size\-\_\-type \&}]{uncut\-Region\-Flag}
\end{DoxyParamCaption}
)}}\label{namespacegetfem_ac08fe08fb325eede94ffe4968b7980de}

\begin{DoxyCode}
736 \{
737 
738     \textcolor{keyword}{const} size\_type shiftPressure = fracture->getMeshFEMPressure().nb\_dof();
739     \textcolor{keyword}{const} size\_type shiftMapFactor = fracture->getMagnificationMapFactor1().size();
740     
741     \hyperlink{Core_8h_a4e75b5863535ba1dd79942de2846eff0}{scalarVector\_Type} D\_(shiftPressure, 0.0), invF(shiftMapFactor, 0);
742 
743     generic\_assembly assem\_Source, assem\_Vx, assem\_Vy;
744 
745     \textcolor{keywordflow}{if} ( fracture->getMeshFEMPressure().get\_qdim() == 1 )
746     \{
747         \textcolor{keywordflow}{for} ( size\_type i = 0; i < shiftMapFactor; ++i )
748         \{
749             invF [ i ] = 1.0 / (fracture->getMagnificationMapFactor1(i));
750         \}
751 
752         \textcolor{comment}{/*}
753 \textcolor{comment}{         * assembla il termine noto}
754 \textcolor{comment}{         * }
755 \textcolor{comment}{         *      sum(i) \{ - (f\_i, q\_i) \}}
756 \textcolor{comment}{         */}
757         assem\_Source.set(\textcolor{stringliteral}{"w=data$1(#2);"} \textcolor{stringliteral}{"q=data$2(#2);"}
758             \textcolor{stringliteral}{"a=comp(Base(#1).Base(#2).Base(#2));"}
759             \textcolor{stringliteral}{"V(#1)+=a(:, k,j).w(k).q(j)"});
760 
761     \}
762     \textcolor{keywordflow}{else}
763     \{
764         \textcolor{keywordflow}{for} ( size\_type i = 0; i < shiftMapFactor; ++i )
765         \{
766             invF [ i ] = 1.0 / (fracture->getMagnificationMapFactor1(i) * fracture->
      getMagnificationMapFactor2(i));
767         \}
768 
769         assem\_Source.set(\textcolor{stringliteral}{"w=data$1(#2);"} \textcolor{stringliteral}{"q=data$2(#2);"}
770             \textcolor{stringliteral}{"a=comp(Base(#1).Base(#2).Base(#2));"}
771             \textcolor{stringliteral}{"V(#1)+=a(:, k,j).w(k).q(j)"});
772 
773     \}
774 
775     \textcolor{comment}{// Assign the M\_mediumMesh integration method}
776     assem\_Source.push\_mi(fracture->getIntegrationMethodPressure());
777 
778     \textcolor{comment}{// Assign the M\_mediumMesh finite element space}
779     assem\_Source.push\_mf(fracture->getMeshFEMPressure());
780 
781     \textcolor{comment}{// Assign the M\_mediumMesh finite element space for the coefficients}
782     assem\_Source.push\_mf(fracture->getMeshFEMPressure());
783     assem\_Source.push\_mf(fracture->getMeshFEMPressure());
784 
785     \textcolor{comment}{// Assign the coefficients}
786     assem\_Source.push\_data(*source);
787     assem\_Source.push\_data(invF);
788 
789     \textcolor{comment}{// Set the vector to save the evaluations}
790     assem\_Source.push\_vec(D\_);
791 
792     \textcolor{comment}{// Computes the matrices}
793     assem\_Source.assembly ( uncutRegionFlag );
794 
795     gmm::add(D\_, gmm::sub\_vector(*D, gmm::sub\_interval(0, shiftPressure)));
796 
797 \} \textcolor{comment}{// assembling\_Source\_BoundaryF}
\end{DoxyCode}
\hypertarget{namespacegetfem_a5efeefe94dfb5427c3ecf63d0b342c57}{\index{getfem@{getfem}!assembling\-\_\-\-Source\-F@{assembling\-\_\-\-Source\-F}}
\index{assembling\-\_\-\-Source\-F@{assembling\-\_\-\-Source\-F}!getfem@{getfem}}
\subsubsection[{assembling\-\_\-\-Source\-F}]{\setlength{\rightskip}{0pt plus 5cm}void getfem\-::assembling\-\_\-\-Source\-F (
\begin{DoxyParamCaption}
\item[{{\bf scalar\-Vector\-Ptr\-\_\-\-Type} \&}]{D, }
\item[{const {\bf scalar\-Vector\-Ptr\-\_\-\-Type} \&}]{source, }
\item[{const {\bf Fracture\-Handler\-Ptr\-\_\-\-Type} \&}]{fracture, }
\item[{const {\bf Fracture\-Handler\-Ptr\-\_\-\-Type} \&}]{other\-Fracture, }
\item[{const size\-\_\-type \&}]{cut\-Region\-Flag}
\end{DoxyParamCaption}
)}}\label{namespacegetfem_a5efeefe94dfb5427c3ecf63d0b342c57}

\begin{DoxyCode}
806 \{
807     \textcolor{keyword}{const} size\_type shiftPressure = fracture->getMeshFEMPressure().nb\_dof();
808     \textcolor{keyword}{const} size\_type shiftMapFactor = fracture->getMagnificationMapFactor1().size();
809     \textcolor{keyword}{const} size\_type otherFractureId = otherFracture->getId();
810     \hyperlink{LevelSetHandler_8h_aba343569cb3213c103252f69c39cad0b}{LevelSetHandlerPtr\_Type}& levelSetOtherFracture = otherFracture->getLevelSet();
811 
812     \hyperlink{Core_8h_a4e75b5863535ba1dd79942de2846eff0}{scalarVector\_Type} DIn ( shiftPressure, 0.0 ), DOut ( shiftPressure, 0.0 ),
813                       invF ( shiftMapFactor, 0 );
814 
815     generic\_assembly assemIn, assemOut;
816 
817     \textcolor{keywordflow}{for} ( size\_type i = 0; i < shiftMapFactor; ++i )
818     \{
819         invF [ i ] = 1.0 / (fracture->getMagnificationMapFactor1(i));
820     \}
821 
822     assemIn.set( \textcolor{stringliteral}{"w=data$1(#2);"} \textcolor{stringliteral}{"q=data$2(#2);"}
823                  \textcolor{stringliteral}{"a=comp(Base(#1).Base(#2).Base(#2));"}
824                  \textcolor{stringliteral}{"V(#1)+=a(:, k,j).w(k).q(j)"} );
825 
826     assemOut.set( \textcolor{stringliteral}{"w=data$1(#2);"} \textcolor{stringliteral}{"q=data$2(#2);"}
827                   \textcolor{stringliteral}{"a=comp(Base(#1).Base(#2).Base(#2));"}
828                   \textcolor{stringliteral}{"V(#1)+=a(:, k,j).w(k).q(j)"} );
829 
830     \textcolor{keyword}{const} getfem::pintegration\_method intTypeIM = getfem::int\_method\_descriptor ( \textcolor{stringliteral}{"IM\_GAUSS1D(3)"} );
831     getfem::mesh\_im\_level\_set meshImLevelSetOut ( *fracture->getMeshLevelSetIntersect ( otherFractureId ),
832                                                   getfem::mesh\_im\_level\_set::INTEGRATE\_OUTSIDE );
833 
834     getfem::mesh\_im\_level\_set meshImLevelSetIn ( *fracture->getMeshLevelSetIntersect ( otherFractureId ),
835                                                  getfem::mesh\_im\_level\_set::INTEGRATE\_INSIDE );
836 
837     meshImLevelSetOut.set\_integration\_method ( fracture->getMeshFlat().convex\_index(), intTypeIM );
838     meshImLevelSetIn.set\_integration\_method ( fracture->getMeshFlat().convex\_index(), intTypeIM );
839 
840     meshImLevelSetOut.set\_simplex\_im ( intTypeIM );
841     meshImLevelSetIn.set\_simplex\_im ( intTypeIM );
842 
843     \textcolor{comment}{// Assign the M\_mediumMesh integration method}
844     assemIn.push\_mi ( meshImLevelSetIn );
845     assemOut.push\_mi ( meshImLevelSetOut );
846 
847     \textcolor{comment}{// Assign the M\_mediumMesh finite element space}
848     assemIn.push\_mf ( fracture->getMeshFEMPressure() );
849     assemOut.push\_mf ( fracture->getMeshFEMPressure() );
850 
851     \textcolor{comment}{// Assign the M\_mediumMesh finite element space for the coefficients}
852     assemIn.push\_mf ( fracture->getMeshFEMPressure() );
853     assemIn.push\_mf ( fracture->getMeshFEMPressure() );
854     assemOut.push\_mf ( fracture->getMeshFEMPressure() );
855     assemOut.push\_mf ( fracture->getMeshFEMPressure() );
856 
857     \textcolor{comment}{// Assign the coefficients}
858     assemIn.push\_data ( *source );
859     assemIn.push\_data ( invF );
860     assemOut.push\_data ( *source );
861     assemOut.push\_data ( invF );
862 
863     \textcolor{comment}{// Set the vector to save the evaluations}
864     assemIn.push\_vec ( DIn );
865     assemOut.push\_vec ( DOut );
866 
867     \textcolor{comment}{// Computes the matrices}
868     assemIn.assembly ( cutRegionFlag );
869     assemOut.assembly ( cutRegionFlag );
870 
871     \textcolor{keyword}{const} \hyperlink{Core_8h_a83c51913d041a5001e8683434c09857f}{sizeVector\_Type}& extendedPressure = fracture->getExtendedPressure();
872     \textcolor{keyword}{const} size\_type extendedNumPressure = fracture->getNumExtendedPressure();
873 
874     \textcolor{keywordflow}{for} ( size\_type i = 0; i < extendedNumPressure; ++i )
875     \{
876         \textcolor{keyword}{const} size\_type ii = extendedPressure [ i ];
877         \textcolor{keyword}{const} base\_node pointFlat = fracture->getMeshFEMPressure().point\_of\_basic\_dof(ii);
878         base\_node pointMapped(0,0);
879         base\_node pointMapped1(0,0);
880     scalar\_type t = ii*1./(fracture->getData().getSpatialDiscretization () );
881         pointMapped[0] = t;
882         pointMapped1[0] = pointFlat[0];
883         pointMapped1[1] = fracture->getLevelSet()->getData()->y\_map( pointMapped );
884         
885     \textcolor{keyword}{const} scalar\_type levelSetValue = levelSetOtherFracture->getData()->ylevelSetFunction ( pointMapped1 );
886 
887         \textcolor{keywordflow}{if} ( levelSetValue < 0 )
888         \{
889             (*D) [ ii ] += DIn [ ii ];
890             (*D) [ i + shiftPressure ] += DOut [ ii ];
891         \}
892         \textcolor{keywordflow}{else}
893         \{
894             (*D) [ ii ] += DOut [ ii ];
895             (*D) [ i + shiftPressure ] += DIn [ ii ];
896         \}
897     \}
898 
899 \} \textcolor{comment}{// assembling\_SourceF}
\end{DoxyCode}
\hypertarget{namespacegetfem_a9a0b9f7498668cda8b547b10ac914a34}{\index{getfem@{getfem}!couple\-Fractures@{couple\-Fractures}}
\index{couple\-Fractures@{couple\-Fractures}!getfem@{getfem}}
\subsubsection[{couple\-Fractures}]{\setlength{\rightskip}{0pt plus 5cm}void getfem\-::couple\-Fractures (
\begin{DoxyParamCaption}
\item[{{\bf sparse\-Matrix\-Ptr\-\_\-\-Type} \&}]{M, }
\item[{const {\bf Fractures\-Set\-Ptr\-\_\-\-Type} \&}]{fractures}
\end{DoxyParamCaption}
)}}\label{namespacegetfem_a9a0b9f7498668cda8b547b10ac914a34}

\begin{DoxyCode}
903 \{
904     \textcolor{keyword}{const} size\_type numFractures = fractures->getNumberFractures ();
905     
906     \textcolor{keyword}{const} size\_type numCross = fractures-> getIntersections ()-> getNumberCross ();
907     \textcolor{keyword}{const} size\_type numBifurcation = fractures-> getIntersections ()-> getNumberBifurcation ();
908 
909     \textcolor{keywordflow}{for} ( size\_type i = 0; i < numFractures; ++i )
910     \{
911         \textcolor{keyword}{const} \hyperlink{FractureHandler_8h_af23fb7a30aaff864bd42587af4f1e78a}{FractureHandlerPtr\_Type}& fracture = fractures->getFracture(i);
912         \textcolor{keyword}{const} \hyperlink{Core_8h_a9bc476e433f99b82a9c2b8560735c7b5}{pairSizeVectorContainer\_Type}& intersectElementsGlobalIndex = 
      fracture->getFractureIntersectElementsGlobalIndex ();
913 
914         \textcolor{keywordflow}{for} ( size\_type j = 0; j < numFractures; ++j )
915         \{
916             \textcolor{keyword}{const} size\_type numIntersections = intersectElementsGlobalIndex [j].size();
917             \textcolor{keywordflow}{for} ( size\_type k = 0; k < numIntersections; ++k )
918             \{
919                 \textcolor{keyword}{const} size\_type first = intersectElementsGlobalIndex [j] [k].first;
920                 \textcolor{keyword}{const} size\_type second = intersectElementsGlobalIndex [j] [k].second;
921                 
922                 \textcolor{keywordflow}{if} ( first < numCross )
923                 \{
924                     (*M)( first, first ) = 1;
925                     (*M)( first, second ) = -1;
926                 \}
927                 
928                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (first >= 2*numCross && first < 2*numCross + 5*numBifurcation )
929                 \{
930                     (*M)( first, first ) = 1;
931                     (*M)( first, second ) = -1;
932                     
933                 \}
934                 
935             \}
936         \}
937     \}
938 
939 \} \textcolor{comment}{// coupleFractures}
\end{DoxyCode}
\hypertarget{namespacegetfem_aba6f1b4f1d395aae3d96071cad4953a2}{\index{getfem@{getfem}!darcy\-\_\-\-A11\-F@{darcy\-\_\-\-A11\-F}}
\index{darcy\-\_\-\-A11\-F@{darcy\-\_\-\-A11\-F}!getfem@{getfem}}
\subsubsection[{darcy\-\_\-\-A11\-F}]{\setlength{\rightskip}{0pt plus 5cm}void getfem\-::darcy\-\_\-\-A11\-F (
\begin{DoxyParamCaption}
\item[{{\bf sparse\-Matrix\-Ptr\-\_\-\-Type} \&}]{M, }
\item[{const {\bf Fracture\-Handler\-Ptr\-\_\-\-Type} \&}]{fracture, }
\item[{const scalar\-\_\-type \&}]{gamma\-U, }
\item[{const {\bf scalar\-Vector\-\_\-\-Type} \&}]{inv\-K\-Tangential\-Interpolated, }
\item[{const {\bf size\-Vector\-\_\-\-Type} \&}]{Ext\-Boundary, }
\item[{const size\-\_\-type \&}]{uncut\-Region\-Flag}
\end{DoxyParamCaption}
)}}\label{namespacegetfem_aba6f1b4f1d395aae3d96071cad4953a2}
getfem\-::generic\-\_\-assembly assem;

assem.\-push\-\_\-im(mim); assem.\-push\-\_\-mf(mf); assem.\-push\-\_\-mf(mfdata); assem.\-push\-\_\-data(\-F); assem.\-push\-\_\-vec(\-B);

assem.\-set(\char`\"{}\-Z=data(\#2);\char`\"{} \char`\"{}\-V(\#1)+=comp(\-Base(\#1).\-Base(\#2))(\-:,j).\-Z(j);\char`\"{});

assem.\-assembly();

The first instructions declare the object, and set the data that it will use\-: a mesh\-\_\-im object which holds the integration methods, two mesh\-\_\-fem objects, the input data F, and the destination vector B.

The input data is the vector F , defined on mfdata. One wants to evaluate sum(j)\{ f\-\_\-j$\ast$ int\-\_\-Ω (φ\-\_\-i $\ast$ ψ\-\_\-j). The instruction must be seen as something that will be executed for each convex cv of the mesh. The terms \#1 and \#2 refer to the first mesh\-\_\-fem and the second one (i.\-e. mf and mfdata). The instruction Z=data(\#2); means that for each convex, the “tensor” Z will receive the values of the first data argument provided with push\-\_\-data, at indexes corresponding to the degrees of freedom attached to the convex of the second (\#2) mesh\-\_\-fem (here, Z = F\mbox{[}mfdata.\-ind\-\_\-dof\-\_\-of\-\_\-element(cv)\mbox{]}. The part V(\#1)+=... means that the result of the next expression will be accumulated into the output vector (provided with push\-\_\-vec). Here again, \#1 means that we will write the result at indexes corresponding to the degrees of freedom of the current convex with respect to the first (\#1) mesh\-\_\-fem.

The right hand side comp(Base(\#1).Base(\#2))(\-:,j).Z(j) contains two operations. The first one is a computation of a tensor on the convex\-: comp(Base(\#1).Base(\#2)) is evaluated as a 2-\/dimensions tensor, int(φ\-\_\-i$\ast$ψ\-\_\-j) , for all degrees of freedom i of mf and j of mfdata attached to the current convex. The next part is a reduction operation, C(\-:,j).Z(j)\-: each named index (here j) is summed, i.\-e. the result is sum(j)\{ c\-\_\-(i,j)$\ast$z\-\_\-j \}.

The integration method used inside comp(Base(\#1).Base(\#2)) is taken from mim.

getfem\-::generic\-\_\-assembly assem;

assem.\-push\-\_\-im(mim); assem.\-push\-\_\-mf(mf); assem.\-push\-\_\-mf(mfdata); assem.\-push\-\_\-data(\-F); assem.\-push\-\_\-vec(\-B);

assem.\-set(\char`\"{}\-Z=data(\#2);\char`\"{} \char`\"{}\-V(\#1)+=comp(\-Base(\#1).\-Base(\#2))(\-:,j).\-Z(j);\char`\"{});

assem.\-assembly();

The first instructions declare the object, and set the data that it will use\-: a mesh\-\_\-im object which holds the integration methods, two mesh\-\_\-fem objects, the input data F, and the destination vector B.

The input data is the vector F , defined on mfdata. One wants to evaluate sum(j)\{ f\-\_\-j$\ast$ int\-\_\-Ω (φ\-\_\-i $\ast$ ψ\-\_\-j). The instruction must be seen as something that will be executed for each convex cv of the mesh. The terms \#1 and \#2 refer to the first mesh\-\_\-fem and the second one (i.\-e. mf and mfdata). The instruction Z=data(\#2); means that for each convex, the “tensor” Z will receive the values of the first data argument provided with push\-\_\-data, at indexes corresponding to the degrees of freedom attached to the convex of the second (\#2) mesh\-\_\-fem (here, Z = F\mbox{[}mfdata.\-ind\-\_\-dof\-\_\-of\-\_\-element(cv)\mbox{]}. The part V(\#1)+=... means that the result of the next expression will be accumulated into the output vector (provided with push\-\_\-vec). Here again, \#1 means that we will write the result at indexes corresponding to the degrees of freedom of the current convex with respect to the first (\#1) mesh\-\_\-fem.

The right hand side comp(Base(\#1).Base(\#2))(\-:,j).Z(j) contains two operations. The first one is a computation of a tensor on the convex\-: comp(Base(\#1).Base(\#2)) is evaluated as a 2-\/dimensions tensor, int(φ\-\_\-i$\ast$ψ\-\_\-j) , for all degrees of freedom i of mf and j of mfdata attached to the current convex. The next part is a reduction operation, C(\-:,j).Z(j)\-: each named index (here j) is summed, i.\-e. the result is sum(j)\{ c\-\_\-(i,j)$\ast$z\-\_\-j \}.

The integration method used inside comp(Base(\#1).Base(\#2)) is taken from mim.
\begin{DoxyCode}
42 \{
43     \textcolor{keyword}{const} size\_type shiftVelocity = fracture->getMeshFEMVelocity().nb\_dof();
44     \textcolor{keyword}{const} size\_type shiftData = fracture->getMeshFEMPressure().nb\_dof();
45 
46     \hyperlink{Core_8h_afba9f623673e2ae32054015bdb5500f9}{sparseMatrix\_Type} M\_;
47     gmm::resize ( M\_, shiftVelocity, shiftVelocity );
48     gmm::clear ( M\_ );
49 
50     \hyperlink{Core_8h_a4e75b5863535ba1dd79942de2846eff0}{scalarVector\_Type} etaGammaUinvh ( shiftData );
51 
52     \textcolor{keywordflow}{for} ( size\_type i = 0; i < shiftData; ++i )
53     \{
54         etaGammaUinvh [ i ] = invKTangentialInterpolated [ i ] * gammaU * fracture->getInverseMeshSize(i);
55     \}
56 
57     \textcolor{comment}{// Volume integration}
58     \textcolor{keyword}{const} size\_type shiftMapFactor = fracture->getMagnificationMapFactor1().size();
59     \hyperlink{Core_8h_a4e75b5863535ba1dd79942de2846eff0}{scalarVector\_Type} invF ( shiftMapFactor, 0. );
60 
61     generic\_assembly assem;
62     
99     \textcolor{keywordflow}{if} ( fracture->getMeshFEMVelocity().get\_qdim() == 1 )
100     \{
101         \textcolor{keywordflow}{for} ( size\_type i = 0; i < shiftMapFactor; ++i )
102         \{
103             invF [ i ] = 1 / fracture->getMagnificationMapFactor1(i);
104         \}
105         \textcolor{comment}{/*}
106 \textcolor{comment}{         *  definisce la forma bilineare:}
107 \textcolor{comment}{         *  }
108 \textcolor{comment}{         *          a\_i(u,w) = (eta\_i * u, w)\_L2}
109 \textcolor{comment}{         *          }
110 \textcolor{comment}{         *  u velocità}
111 \textcolor{comment}{         *  w funzione test per la velocità}
112 \textcolor{comment}{         *  }
113 \textcolor{comment}{         *  #1 velocità}
114 \textcolor{comment}{         *  #2 pressione}
115 \textcolor{comment}{         *          }
116 \textcolor{comment}{         */}
117         assem.set(\textcolor{stringliteral}{"w=data$1(#2);"} \textcolor{stringliteral}{"q=data$2(#2);"}
118                   \textcolor{stringliteral}{"a=comp(Base(#1).Base(#1).Base(#2).Base(#2));"}
119                   \textcolor{stringliteral}{"M(#1,#1)+=a(:, :, i,k).w(i).q(k);"});
120     \}
121     \textcolor{keywordflow}{else}
122     \{
123         \textcolor{keywordflow}{for} ( size\_type i = 0; i < shiftMapFactor; ++i )
124         \{
125             invF [ i ] = 1 / (fracture->getMagnificationMapFactor1(i)
126                     * fracture->getMagnificationMapFactor2(i));
127         \}
128         assem.set(\textcolor{stringliteral}{"w=data(#2);"} \textcolor{stringliteral}{"q=data$2(#2);"}
129             \textcolor{stringliteral}{"a=comp(vBase(#1).vBase(#1).Base(#2).Base(#2));"}
130             \textcolor{stringliteral}{"M(#1,#1)+=a(:,i,:,i,j,k).w(j).q(k);"});
131     \}
132 
133     \textcolor{comment}{// Assegno il metodo di integrazione su M\_mediumMesh }
134     assem.push\_mi(fracture->getIntegrationMethodVelocity());
135 
136     \textcolor{comment}{// Assegno lo spazio degli elementi finiti su M\_mediumMesh }
137     assem.push\_mf(fracture->getMeshFEMVelocity());
138 
139     \textcolor{comment}{// Assegno lo spazio degli elementi finiti su M\_mediumMesh per i coefficienti}
140     assem.push\_mf(fracture->getMeshFEMPressure());
141     assem.push\_mf(fracture->getMeshFEMPressure());
142 
143     \textcolor{comment}{// Assegno i coefficienti}
144     assem.push\_data(invKTangentialInterpolated);
145     assem.push\_data(invF);
146 
147     \textcolor{comment}{// Definisco la matrice dove salare i risultati}
148     assem.push\_mat(M\_);
149 
150     \textcolor{comment}{// Calcolo la matrice}
151     assem.assembly ( uncutRegionFlag );
152 
153     \textcolor{keywordflow}{for} ( size\_type i = 0; i < shiftVelocity; ++i )
154     \{
155         \textcolor{keywordflow}{for} ( size\_type j = 0; j < shiftVelocity; ++j )
156         \{
157             (*M)(i, j) = M\_(i, j);
158         \}
159     \};
160 
161     cout << \textcolor{stringliteral}{"DARCY :: operator a(volume)      [OK]"} << endl;
162 
163     \textcolor{comment}{// Boundary integration for the fracture}
164     gmm::clear(M\_);
165 
166     getfem::generic\_assembly assem\_surf;
167 
168     \textcolor{comment}{/*}
169 \textcolor{comment}{     * tratta il termine di bordo non soggetto a condizione al contorno di dirichlet per la pressione}
170 \textcolor{comment}{     * }
171 \textcolor{comment}{     */} 
172     assem\_surf.set(\textcolor{stringliteral}{"gamma=data$1(#2);"}
173                    \textcolor{stringliteral}{"t=comp(vBase(#1).Normal().vBase(#1).Normal().Base(#2));"}        
174                    \textcolor{stringliteral}{"M$1(#1,#1)+=(t(:,i, i, :,j, j, k).gamma(k));"});
175 
176     \textcolor{comment}{// Assegno il metodo di integrazione su M\_mediumMesh }
177     assem\_surf.push\_mi(fracture->getIntegrationMethodVelocity());
178 
179     \textcolor{comment}{// Assegno lo spazio degli elementi finiti su M\_mediumMesh }
180     assem\_surf.push\_mf(fracture->getMeshFEMVelocity());
181 
182     \textcolor{comment}{// Assegno lo spazio degli elementi finiti su M\_mediumMesh per i coefficienti}
183     assem\_surf.push\_mf(fracture->getMeshFEMPressure());
184 
185     \textcolor{comment}{// Assegno i coefficienti}
186     assem\_surf.push\_data(etaGammaUinvh);
187 
188     \textcolor{comment}{// Definisco la matrice dove salare i risultati}
189     assem\_surf.push\_mat(M\_);
190 
191     \textcolor{comment}{// Assemblo la matrice su ogni sottoregione}
192     \textcolor{keywordflow}{for} ( size\_type bndID = 0; bndID < ExtBoundary.size(); bndID++ )
193     \{
194         assem\_surf.assembly(
195                 fracture->getMeshFEMVelocity().linked\_mesh().get\_mpi\_sub\_region(
196                         ExtBoundary [ bndID ]));
197     \}
198 
199     \textcolor{keywordflow}{for} ( size\_type i = 0; i < shiftVelocity; ++i )
200     \{
201         \textcolor{keywordflow}{for} ( size\_type j = 0; j < shiftVelocity; ++j )
202         \{
203             (*M)(i, j) += M\_(i, j);
204         \}
205     \}
206     cout << \textcolor{stringliteral}{"DARCY :: operator a(surface)     [OK]"} << endl;
207 
208 \} \textcolor{comment}{// darcy\_A11F}
\end{DoxyCode}
\hypertarget{namespacegetfem_a9b6ded8fe1019aa04e66d2047d0f29dd}{\index{getfem@{getfem}!darcy\-\_\-\-A11\-F\-\_\-\-Cross@{darcy\-\_\-\-A11\-F\-\_\-\-Cross}}
\index{darcy\-\_\-\-A11\-F\-\_\-\-Cross@{darcy\-\_\-\-A11\-F\-\_\-\-Cross}!getfem@{getfem}}
\subsubsection[{darcy\-\_\-\-A11\-F\-\_\-\-Cross}]{\setlength{\rightskip}{0pt plus 5cm}void getfem\-::darcy\-\_\-\-A11\-F\-\_\-\-Cross (
\begin{DoxyParamCaption}
\item[{{\bf sparse\-Matrix\-Ptr\-\_\-\-Type} \&}]{M, }
\item[{const {\bf Fracture\-Handler\-Ptr\-\_\-\-Type} \&}]{fracture, }
\item[{const {\bf scalar\-Vector\-\_\-\-Type} \&}]{inv\-K\-Tangential\-Interpolated, }
\item[{const {\bf Fracture\-Handler\-Ptr\-\_\-\-Type} \&}]{other\-Fracture, }
\item[{const size\-\_\-type \&}]{cut\-Region\-Flag}
\end{DoxyParamCaption}
)}}\label{namespacegetfem_a9b6ded8fe1019aa04e66d2047d0f29dd}

\begin{DoxyCode}
217 \{
218     \textcolor{keyword}{const} size\_type shiftVelocity = fracture->getMeshFEMVelocity().nb\_dof();
219     
220     \hyperlink{Core_8h_afba9f623673e2ae32054015bdb5500f9}{sparseMatrix\_Type} MIn, MOut, Gamma;
221     gmm::resize ( MOut, shiftVelocity, shiftVelocity );
222     gmm::clear ( MOut );
223     gmm::resize ( MIn, shiftVelocity, shiftVelocity );
224     gmm::clear ( MIn );
225     gmm::resize ( Gamma, shiftVelocity, shiftVelocity );
226     gmm::clear ( Gamma );
227 
228     \textcolor{keyword}{const} size\_type otherFractureId = otherFracture->getId();
229     \hyperlink{LevelSetHandler_8h_aba343569cb3213c103252f69c39cad0b}{LevelSetHandlerPtr\_Type}& levelSetOtherFracture = otherFracture->getLevelSet();
230 
231     \textcolor{keyword}{const} size\_type shiftMapFactor = fracture->getMagnificationMapFactor1().size();
232     \hyperlink{Core_8h_a4e75b5863535ba1dd79942de2846eff0}{scalarVector\_Type} invF ( shiftMapFactor, 0. );
233 
234     \textcolor{keywordflow}{for} ( size\_type i = 0; i < shiftMapFactor; ++i )
235     \{
236         invF [ i ] = 1 / fracture->getMagnificationMapFactor1(i);
237     \}
238 
239     generic\_assembly assemIn, assemOut, assemGam;
240 
241     assemIn.set(\textcolor{stringliteral}{"w=data(#2);"} \textcolor{stringliteral}{"q=data$2(#2);"}
242                 \textcolor{stringliteral}{"a=comp(Base(#1).Base(#1).Base(#2).Base(#2));"}
243                 \textcolor{stringliteral}{"M(#1,#1)+=a(:,:,j,k).w(j).q(k);"});
244 
245     assemOut.set(\textcolor{stringliteral}{"w=data(#2);"} \textcolor{stringliteral}{"q=data$2(#2);"}
246                  \textcolor{stringliteral}{"a=comp(Base(#1).Base(#1).Base(#2).Base(#2));"}
247                  \textcolor{stringliteral}{"M(#1,#1)+=a(:,:,j,k).w(j).q(k);"});
248 
249     \textcolor{keyword}{const} getfem::pintegration\_method intTypeIM = getfem::int\_method\_descriptor ( \textcolor{stringliteral}{"IM\_GAUSS1D(3)"} );
250     getfem::mesh\_im\_level\_set meshImLevelSetOut ( *fracture->getMeshLevelSetIntersect ( otherFractureId ),
251                                                   getfem::mesh\_im\_level\_set::INTEGRATE\_OUTSIDE );
252 
253     getfem::mesh\_im\_level\_set meshImLevelSetIn ( *fracture->getMeshLevelSetIntersect ( otherFractureId ),
254                                                  getfem::mesh\_im\_level\_set::INTEGRATE\_INSIDE );
255 
256     meshImLevelSetOut.set\_integration\_method ( fracture->getMeshFlat().convex\_index(), intTypeIM );
257     meshImLevelSetIn.set\_integration\_method ( fracture->getMeshFlat().convex\_index(), intTypeIM );
258 
259     meshImLevelSetOut.set\_simplex\_im ( intTypeIM );
260     meshImLevelSetIn.set\_simplex\_im ( intTypeIM );
261 
262 
263     \textcolor{comment}{// Assegno il metodo di integrazioned}
264     assemIn.push\_mi ( meshImLevelSetIn );
265     assemOut.push\_mi ( meshImLevelSetOut );
266 
267     \textcolor{comment}{// Assegno lo spazio deglie elementi finiti per la velocità}
268     assemIn.push\_mf ( fracture->getMeshFEMVelocity() );
269     assemOut.push\_mf ( fracture->getMeshFEMVelocity() );
270 
271     \textcolor{comment}{// Assegno lo spazio deglie elementi finiti per i coefficienti}
272     assemIn.push\_mf ( fracture->getMeshFEMPressure() );
273     assemOut.push\_mf ( fracture->getMeshFEMPressure() );
274 
275     \textcolor{comment}{// Assegno i coefficienti}
276     assemIn.push\_data ( invKTangentialInterpolated );
277     assemIn.push\_data ( invF );
278 
279     assemOut.push\_data ( invKTangentialInterpolated );
280     assemOut.push\_data ( invF );
281 
282     assemOut.push\_mat ( MOut );
283     assemIn.push\_mat ( MIn );
284 
285     assemOut.assembly ( cutRegionFlag );
286     assemIn.assembly ( cutRegionFlag );
287 
288     \textcolor{comment}{// Aggiorno i gradi di libertà estesi}
289     \textcolor{keyword}{const} \hyperlink{Core_8h_a83c51913d041a5001e8683434c09857f}{sizeVector\_Type}& extendedVelocity = fracture->getExtendedVelocity();
290     \textcolor{keyword}{const} size\_type extendedNumVelocity = fracture->getNumExtendedVelocity();
291 
292     \textcolor{keywordflow}{for} ( size\_type i = 0; i < extendedNumVelocity; ++i )
293     \{
294         \textcolor{keyword}{const} size\_type ii = extendedVelocity [ i ];
295         \textcolor{keyword}{const} base\_node pointFlat = fracture->getMeshFEMVelocity().point\_of\_basic\_dof(ii);
296         
297         base\_node pointMapped(0,0);
298         base\_node pointMapped1(0,0);
299         scalar\_type t = ii*1./(fracture->getData().getSpatialDiscretization () );
300         pointMapped[0]= t;
301         pointMapped1[0] = pointFlat[0];
302         pointMapped1[1] = fracture->getLevelSet()->getData()->y\_map( pointMapped );
303     
304         \textcolor{keyword}{const} scalar\_type levelSetValue1 = levelSetOtherFracture->getData()->ylevelSetFunction ( 
      pointMapped1 );
305 
306         \textcolor{keywordflow}{for} ( size\_type j = 0; j < extendedNumVelocity; ++j )
307         \{
308             \textcolor{keyword}{const} size\_type jj = extendedVelocity [ j ];
309             \textcolor{keyword}{const} base\_node pointFlat = fracture->getMeshFEMVelocity().point\_of\_basic\_dof(jj);
310         
311             base\_node pointMapped(0,0);
312             base\_node pointMapped1(0,0);
313             scalar\_type t = jj*1./(fracture->getData().getSpatialDiscretization () );
314             pointMapped[0] = t;
315             pointMapped1[0] = pointFlat[0];
316             pointMapped1[1] = fracture->getLevelSet()->getData()->y\_map( pointMapped );
317 
318             \textcolor{keyword}{const} scalar\_type levelSetValue2 = levelSetOtherFracture->getData()->ylevelSetFunction ( 
      pointMapped1 );
319 
320             \textcolor{keywordflow}{if} ( levelSetValue1 < 0 && levelSetValue2 < 0 )
321             \{
322                 \textcolor{comment}{// i and j are both In}
323                 (*M)(ii, jj) += MIn ( ii, jj );
324                 (*M)(i + shiftVelocity, j + shiftVelocity) += MOut ( ii, jj );
325             \}
326 
327             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( levelSetValue1 >= 0 && levelSetValue2 >= 0 )
328             \{
329                 \textcolor{comment}{// i and j are both Out}
330                 (*M)(ii, jj) += MOut(ii, jj);
331                 (*M)(i + shiftVelocity, j + shiftVelocity) += MIn(ii, jj);
332             \}
333             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( levelSetValue1 < 0 && levelSetValue2 >= 0 )
334             \{
335                 \textcolor{comment}{// i is In, j is Out}
336                 (*M)(ii, j + shiftVelocity) += MIn(ii, jj);
337                 (*M)(i + shiftVelocity, jj) += MOut(ii, jj);
338             \}
339             \textcolor{keywordflow}{else}
340             \{
341                 \textcolor{comment}{// i is Out, j is In}
342                 (*M)(i + shiftVelocity, jj) += MIn(ii, jj);
343                 (*M)(ii, j + shiftVelocity) += MOut(ii, jj);
344             \}
345         \}
346     \}
347 
348     \textcolor{comment}{// Calcolo l'integrale \{u dot n\}\{v dot n\}}
349 
350     \hyperlink{Core_8h_a4e75b5863535ba1dd79942de2846eff0}{scalarVector\_Type} otherFractureEtaNormal ( fracture->getMeshFEMPressure().nb\_dof(), 0.
       );
351 
352     \textcolor{keywordflow}{for} ( size\_type i = 0; i < fracture->getMeshFEMPressure().nb\_dof(); ++i )
353     \{
354         base\_node nodo = fracture->getMeshFEMPressure().point\_of\_basic\_dof( i );
355         otherFractureEtaNormal [ i ] = otherFracture->getData().getEtaNormal () *
356                     otherFracture->getData().etaNormalDistribution ( nodo ) / fracture->getData().
      getThickness();
357     \}
358 
359     assemGam.set(\textcolor{stringliteral}{"w=data(#2);"}
360         \textcolor{stringliteral}{"a=comp(vBase(#1).NonLin(#3).vBase(#1).NonLin(#3).Base(#2));"}
361         \textcolor{stringliteral}{"M(#1,#1)+=a(:,j,j,:,i,i,k).w(k);"});
362 
363     level\_set\_unit\_normal nterm ( fracture->getMeshLevelSetIntersect ( otherFractureId )->get\_level\_set(0)
      ->get\_mesh\_fem(),
364                                   fracture->getMeshLevelSetIntersect ( otherFractureId )->get\_level\_set(0)
      ->values() );
365 
366     getfem::mesh\_im\_level\_set meshImLevel ( *fracture->getMeshLevelSetIntersect ( otherFractureId ),
367                                             getfem::mesh\_im\_level\_set::INTEGRATE\_BOUNDARY );
368 
369     meshImLevel.set\_integration\_method ( fracture->getMeshFlat().convex\_index(), intTypeIM );
370 
371     meshImLevel.set\_simplex\_im ( intTypeIM );
372 
373     \textcolor{comment}{// Assegno il metodo di integrazione sulla mesh}
374     assemGam.push\_mi ( meshImLevel );
375 
376     \textcolor{comment}{// Assegno lo spazio deglie elementi finiti}
377     assemGam.push\_mf ( fracture->getMeshFEMVelocity() );
378     assemGam.push\_mf ( fracture->getMeshFEMPressure() );
379 
380     \textcolor{comment}{// Assegno il termine non lineare}
381     assemGam.push\_nonlinear\_term ( &nterm );
382 
383     \textcolor{comment}{// Assegno lo spazio deglie elementi finiti per i coefficienti}
384     assemGam.push\_mf ( fracture->getMeshLevelSetIntersect ( otherFractureId )->get\_level\_set(0)->
      get\_mesh\_fem() );
385 
386     \textcolor{comment}{// Assegno i coefficienti}
387     assemGam.push\_data ( otherFractureEtaNormal );
388 
389     \textcolor{comment}{// Set the matrices to save the evaluations}
390     assemGam.push\_mat ( Gamma  );
391 
392     \textcolor{comment}{// Computes the matrices}
393     assemGam.assembly ( cutRegionFlag );
394 
395     \textcolor{comment}{// Add the extended degrees of freedom}
396     \textcolor{keywordflow}{for} ( size\_type i = 0; i < extendedNumVelocity; ++i )
397     \{
398         \textcolor{keyword}{const} size\_type ii = extendedVelocity [ i ];
399         \textcolor{keywordflow}{for} ( size\_type j = 0; j < extendedNumVelocity; ++j )
400         \{
401             \textcolor{keyword}{const} size\_type jj = extendedVelocity [ j ];
402 
403             (*M)(ii, jj) += 0.25 * Gamma(ii, jj);
404             (*M)(i + shiftVelocity, j + shiftVelocity) += 0.25 * Gamma(ii, jj);
405             (*M)(i + shiftVelocity, jj) += 0.25 * Gamma(ii, jj);
406             (*M)(ii, j + shiftVelocity) += 0.25 * Gamma(ii, jj);
407         \}
408     \}
409 
410 \} \textcolor{comment}{// darcy\_A11F}
\end{DoxyCode}
\hypertarget{namespacegetfem_ab62aa98cfcf55810e1518906202cbedc}{\index{getfem@{getfem}!darcy\-\_\-\-A12\-F@{darcy\-\_\-\-A12\-F}}
\index{darcy\-\_\-\-A12\-F@{darcy\-\_\-\-A12\-F}!getfem@{getfem}}
\subsubsection[{darcy\-\_\-\-A12\-F}]{\setlength{\rightskip}{0pt plus 5cm}void getfem\-::darcy\-\_\-\-A12\-F (
\begin{DoxyParamCaption}
\item[{{\bf sparse\-Matrix\-Ptr\-\_\-\-Type} \&}]{M, }
\item[{const {\bf Fracture\-Handler\-Ptr\-\_\-\-Type} \&}]{fracture, }
\item[{const size\-\_\-type \&}]{uncut\-Region\-Flag}
\end{DoxyParamCaption}
)}}\label{namespacegetfem_ab62aa98cfcf55810e1518906202cbedc}

\begin{DoxyCode}
418 \{
419     \textcolor{keyword}{const} size\_type velocityShift = fracture->getMeshFEMVelocity().nb\_dof();
420     \textcolor{keyword}{const} size\_type pressureShift = fracture->getMeshFEMPressure().nb\_dof();
421 
422     \hyperlink{Core_8h_afba9f623673e2ae32054015bdb5500f9}{sparseMatrix\_Type} M\_;
423 
424     gmm::resize(M\_, velocityShift, pressureShift);
425     gmm::clear(M\_);
426 
427     \textcolor{comment}{// Volume integration}
428     getfem::generic\_assembly assem;
429 
430     \textcolor{keywordflow}{if} ( fracture->getMeshFEMVelocity().get\_qdim() == 1 )
431     \{
432         \textcolor{comment}{/*}
433 \textcolor{comment}{         * definisce la forma bilineare}
434 \textcolor{comment}{         * }
435 \textcolor{comment}{         *      b\_i(q,w) = - (q, div(w))\_L2}
436 \textcolor{comment}{         *  }
437 \textcolor{comment}{         *  w funzione test per la velocità}
438 \textcolor{comment}{         *  q funzione test per la pressione}
439 \textcolor{comment}{         *  }
440 \textcolor{comment}{         */}
441         assem.set(\textcolor{stringliteral}{"M(#1,#2)+=-comp(vGrad(#1).Base(#2))"} \textcolor{stringliteral}{"(:, i,i,:);"}); \textcolor{comment}{// ma non ci va un prodotto scalare
       in L2?}
442     \}
443     \textcolor{keywordflow}{else}
444     \{
445         assem.set(\textcolor{stringliteral}{"M(#1,#2)+=-comp(vGrad(#1).Base(#2))"} \textcolor{stringliteral}{"(:,i,i, :);"});
446     \}
447 
448     \textcolor{comment}{// Assign the M\_mediumMesh integration method}
449     assem.push\_mi(fracture->getIntegrationMethodVelocity());
450 
451     \textcolor{comment}{// Assign the M\_mediumMesh finite element space}
452     assem.push\_mf(fracture->getMeshFEMVelocity());
453     assem.push\_mf(fracture->getMeshFEMPressure());
454 
455     \textcolor{comment}{// Set the matrices to save the evaluations}
456     assem.push\_mat(M\_);
457 
458     \textcolor{comment}{// Computes the matrices}
459     assem.assembly ( uncutRegionFlag );
460 
461     \textcolor{keywordflow}{for} ( size\_type i = 0; i < velocityShift; ++i )
462     \{
463         \textcolor{keywordflow}{for} ( size\_type j = 0; j < pressureShift; ++j )
464         \{
465             (*M)(i, j) = M\_(i, j);
466         \}
467     \};
468 
469     cout << \textcolor{stringliteral}{"DARCY :: operator b(volumic)     [OK]"} << endl;
470 
471 \} \textcolor{comment}{// darcy\_A12F}
\end{DoxyCode}
\hypertarget{namespacegetfem_a88df6c0cb0765d5ab0fae27679cd30f4}{\index{getfem@{getfem}!darcy\-\_\-\-A12\-F\-\_\-\-Cross@{darcy\-\_\-\-A12\-F\-\_\-\-Cross}}
\index{darcy\-\_\-\-A12\-F\-\_\-\-Cross@{darcy\-\_\-\-A12\-F\-\_\-\-Cross}!getfem@{getfem}}
\subsubsection[{darcy\-\_\-\-A12\-F\-\_\-\-Cross}]{\setlength{\rightskip}{0pt plus 5cm}void getfem\-::darcy\-\_\-\-A12\-F\-\_\-\-Cross (
\begin{DoxyParamCaption}
\item[{{\bf sparse\-Matrix\-Ptr\-\_\-\-Type} \&}]{M, }
\item[{const {\bf Fracture\-Handler\-Ptr\-\_\-\-Type} \&}]{fracture, }
\item[{const {\bf Fracture\-Handler\-Ptr\-\_\-\-Type} \&}]{other\-Fracture, }
\item[{const size\-\_\-type \&}]{cut\-Region\-Flag}
\end{DoxyParamCaption}
)}}\label{namespacegetfem_a88df6c0cb0765d5ab0fae27679cd30f4}

\begin{DoxyCode}
479 \{
480     \textcolor{keyword}{const} size\_type velocityShift = fracture->getMeshFEMVelocity().nb\_dof();
481     \textcolor{keyword}{const} size\_type pressureShift = fracture->getMeshFEMPressure().nb\_dof();
482 
483     \hyperlink{Core_8h_afba9f623673e2ae32054015bdb5500f9}{sparseMatrix\_Type} MIn, MOut;
484 
485     gmm::resize(MIn, velocityShift, pressureShift);
486     gmm::clear(MIn);
487     gmm::resize(MOut, velocityShift, pressureShift);
488     gmm::clear(MOut);
489 
490     \textcolor{keyword}{const} size\_type otherFractureId = otherFracture->getId();
491     \hyperlink{LevelSetHandler_8h_aba343569cb3213c103252f69c39cad0b}{LevelSetHandlerPtr\_Type}& levelSetOtherFracture = otherFracture->getLevelSet();
492 
493     \textcolor{comment}{// Volume integration}
494     getfem::generic\_assembly assemIn, assemOut;
495 
496     assemIn.set(\textcolor{stringliteral}{"M(#1,#2)+=-comp(vGrad(#1).Base(#2))"}
497                 \textcolor{stringliteral}{"(:, i,i,:);"});
498     assemOut.set(\textcolor{stringliteral}{"M(#1,#2)+=-comp(vGrad(#1).Base(#2))"}
499                  \textcolor{stringliteral}{"(:, i,i,:);"});
500 
501     \textcolor{keyword}{const} getfem::pintegration\_method intTypeIM = getfem::int\_method\_descriptor ( \textcolor{stringliteral}{"IM\_GAUSS1D(3)"} );
502     getfem::mesh\_im\_level\_set meshImLevelSetOut ( *fracture->getMeshLevelSetIntersect ( otherFractureId ),
503                                                   getfem::mesh\_im\_level\_set::INTEGRATE\_OUTSIDE );
504 
505     getfem::mesh\_im\_level\_set meshImLevelSetIn ( *fracture->getMeshLevelSetIntersect ( otherFractureId ),
506                                                  getfem::mesh\_im\_level\_set::INTEGRATE\_INSIDE );
507 
508     meshImLevelSetOut.set\_integration\_method ( fracture->getMeshFlat().convex\_index(), intTypeIM );
509     meshImLevelSetIn.set\_integration\_method ( fracture->getMeshFlat().convex\_index(), intTypeIM );
510 
511     meshImLevelSetOut.set\_simplex\_im ( intTypeIM );
512     meshImLevelSetIn.set\_simplex\_im ( intTypeIM );
513 
514     \textcolor{comment}{// Assign the mesh integration method}
515     assemIn.push\_mi ( meshImLevelSetIn );
516     assemOut.push\_mi ( meshImLevelSetOut );
517 
518     \textcolor{comment}{// Assign the M\_mediumMesh finite element space}
519     assemIn.push\_mf ( fracture->getMeshFEMVelocity() );
520     assemIn.push\_mf ( fracture->getMeshFEMPressure() );
521 
522     assemOut.push\_mf ( fracture->getMeshFEMVelocity() );
523     assemOut.push\_mf ( fracture->getMeshFEMPressure() );
524 
525     \textcolor{comment}{// Set the matrices to save the evaluations}
526     assemIn.push\_mat ( MIn );
527     assemOut.push\_mat ( MOut );
528 
529     \textcolor{comment}{// Computes the matrices}
530     assemIn.assembly ( cutRegionFlag );
531     assemOut.assembly ( cutRegionFlag );
532 
533     \textcolor{comment}{// Update the extended degrees of freedom}
534     \textcolor{keyword}{const} \hyperlink{Core_8h_a83c51913d041a5001e8683434c09857f}{sizeVector\_Type}& extendedVelocity = fracture->getExtendedVelocity();
535     \textcolor{keyword}{const} size\_type extendedNumVelocity = fracture->getNumExtendedVelocity();
536     \textcolor{keyword}{const} \hyperlink{Core_8h_a83c51913d041a5001e8683434c09857f}{sizeVector\_Type}& extendedPressure = fracture->getExtendedPressure();
537     \textcolor{keyword}{const} size\_type extendedNumPressure = fracture->getNumExtendedPressure();
538 
539     \textcolor{keywordflow}{for} ( size\_type i = 0; i < extendedNumVelocity; ++i )
540     \{
541         \textcolor{keyword}{const} size\_type ii = extendedVelocity [ i ];
542         \textcolor{keyword}{const} base\_node pointFlat = fracture->getMeshFEMVelocity().point\_of\_basic\_dof(ii);
543         base\_node pointMapped(0,0);
544         base\_node pointMapped1(0,0);
545     scalar\_type t = ii*1./(fracture->getData().getSpatialDiscretization () );
546         pointMapped[0] = t;
547         pointMapped1[0] = pointFlat[0];
548         pointMapped1[1] = fracture->getLevelSet()->getData()->y\_map( pointMapped );
549 
550         \textcolor{keyword}{const} scalar\_type levelSetValue1 = levelSetOtherFracture->getData()->ylevelSetFunction ( 
      pointMapped1 );
551 
552         \textcolor{keywordflow}{for} ( size\_type j = 0; j < extendedNumPressure; ++j )
553         \{
554             \textcolor{keyword}{const} size\_type jj = extendedPressure [ j ];
555             \textcolor{keyword}{const} base\_node pointFlat = fracture->getMeshFEMPressure().point\_of\_basic\_dof(jj);
556             base\_node pointMapped(0,0);
557             base\_node pointMapped1(0,0);
558             scalar\_type t = jj*1./(fracture->getData().getSpatialDiscretization () );
559             pointMapped[0] = t;
560             pointMapped1[0] = pointFlat[0];
561             pointMapped1[1] = fracture->getLevelSet()->getData()->y\_map( pointMapped );
562            
563         \textcolor{keyword}{const} scalar\_type levelSetValue2 = levelSetOtherFracture->getData()->ylevelSetFunction ( 
      pointMapped1 );
564 
565             \textcolor{keywordflow}{if} ( levelSetValue1 < 0 && levelSetValue2 < 0 )
566             \{
567                 \textcolor{comment}{// i and j are both In}
568                 (*M)(ii, jj) += MIn ( ii, jj );
569                 (*M)(i + velocityShift, j + pressureShift) += MOut ( ii, jj );
570             \}
571 
572             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( levelSetValue1 >= 0 && levelSetValue2 >= 0 )
573             \{
574                 \textcolor{comment}{// i and j are both Out}
575                 (*M)(ii, jj) += MOut(ii, jj);
576                 (*M)(i + velocityShift, j + pressureShift) += MIn(ii, jj);
577             \}
578             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( levelSetValue1 < 0 && levelSetValue2 >= 0 )
579             \{
580                 \textcolor{comment}{// i is In, j is Out}
581                 (*M)(ii, j + pressureShift) += MIn(ii, jj);
582                 (*M)(i + velocityShift, jj) += MOut(ii, jj);
583             \}
584             \textcolor{keywordflow}{else}
585             \{
586                 \textcolor{comment}{// i is Out, j is In}
587                 (*M)(i + velocityShift, jj) += MIn(ii, jj);
588                 (*M)(ii, j + pressureShift) += MOut(ii, jj);
589             \}
590         \}
591     \}
592 
593 \} \textcolor{comment}{// darcy\_A12F}
\end{DoxyCode}
\hypertarget{namespacegetfem_ad6e90b309c01f6b4fc91c9369cba376a}{\index{getfem@{getfem}!darcy\-\_\-data\-F@{darcy\-\_\-data\-F}}
\index{darcy\-\_\-data\-F@{darcy\-\_\-data\-F}!getfem@{getfem}}
\subsubsection[{darcy\-\_\-data\-F}]{\setlength{\rightskip}{0pt plus 5cm}void getfem\-::darcy\-\_\-data\-F (
\begin{DoxyParamCaption}
\item[{{\bf scalar\-Vector\-Ptr\-\_\-\-Type} \&}]{Bstress, }
\item[{{\bf scalar\-Vector\-Ptr\-\_\-\-Type} \&}]{Bvel, }
\item[{const {\bf B\-C\-Handler\-Ptr\-\_\-\-Type} \&}]{bc\-Handler, }
\item[{const {\bf Fracture\-Handler\-Ptr\-\_\-\-Type} \&}]{fracture, }
\item[{const scalar\-\_\-type \&}]{gamma\-U, }
\item[{const scalar\-\_\-type \&}]{inv\-K, }
\item[{const {\bf scalar\-Vector\-Ptr\-\_\-\-Type} \&}]{Pneumann, }
\item[{const {\bf scalar\-Vector\-Ptr\-\_\-\-Type} \&}]{v\-\_\-diri}
\end{DoxyParamCaption}
)}}\label{namespacegetfem_ad6e90b309c01f6b4fc91c9369cba376a}

\begin{DoxyCode}
606 \{
607 
608     \textcolor{comment}{// ----------------- Penalty    ---------------}
609 
610     \textcolor{keyword}{const} scalar\_type fractureID = fracture->getId();
611     \textcolor{keyword}{const} \hyperlink{LevelSetHandler_8h_aba343569cb3213c103252f69c39cad0b}{LevelSetHandlerPtr\_Type}& levelSet = fracture->getLevelSet();
612     \textcolor{keyword}{const} size\_type shiftVelocity = fracture->getMeshFEMVelocity().nb\_dof();
613     \textcolor{keyword}{const} size\_type shiftCoefficinents =
614             fracture->getMeshFEMPressure().nb\_dof();
615 
616     \hyperlink{Core_8h_a4e75b5863535ba1dd79942de2846eff0}{scalarVector\_Type} etaGammaUinvh(shiftCoefficinents, 0.), Bvel\_tot(
617             shiftVelocity, 0.);
618 
619     \textcolor{keywordflow}{for} ( size\_type i = 0; i < shiftCoefficinents; ++i )
620     \{
621         etaGammaUinvh [ i ] = invK * gammaU * fracture->getInverseMeshSize(i);
622     \}
623 
624     getfem::generic\_assembly assem2;
625 
626     assem2.set(\textcolor{stringliteral}{"gamma=data$1(#2);"} \textcolor{stringliteral}{"vel=data$2(#2);"}
627         \textcolor{stringliteral}{"t=comp(Base(#2).vBase(#1).Normal().Base(#2));"}
628         \textcolor{stringliteral}{"V(#1)+=(t(m, :,j, j, k).gamma(k).vel(m));"});
629 
630     \textcolor{comment}{// Assign the M\_mediumMesh integration method}
631     assem2.push\_mi(fracture->getIntegrationMethodVelocity());
632 
633     \textcolor{comment}{// Assign the M\_mediumMesh finite element space}
634     assem2.push\_mf(fracture->getMeshFEMVelocity());
635 
636     \textcolor{comment}{// Assign the M\_mediumMesh finite element space for the coefficients}
637     assem2.push\_mf(fracture->getMeshFEMPressure());
638     assem2.push\_mf(fracture->getMeshFEMPressure());
639 
640     \textcolor{comment}{// Assign the coefficients}
641     assem2.push\_data(etaGammaUinvh);
642     assem2.push\_data(*v\_diri);
643 
644     \textcolor{comment}{// Set the matrices to save the evaluations}
645     assem2.push\_vec(Bvel\_tot);
646 
647     \textcolor{comment}{// Assemble in each sub region}
648     \textcolor{keyword}{const} size\_type shiftDirichlet =
649             bcHandler->getFractureBC(fractureID)->getDirichlet().size();
650     \textcolor{keywordflow}{for} ( size\_type bndID = 0; bndID < shiftDirichlet; bndID++ )
651     \{
652         \textcolor{keyword}{const} size\_type val = bcHandler->getFractureBC(fractureID)->getDirichlet(bndID);
653         assem2.assembly( fracture->getMeshFEMVelocity().linked\_mesh().get\_mpi\_sub\_region( val));
654     \}
655 
656     \textcolor{keywordflow}{for} ( size\_type i = 0; i < shiftVelocity; ++i )
657     \{
658         (*Bvel) [ i ] += Bvel\_tot [ i ];
659     \}
660 
661     cout << \textcolor{stringliteral}{"DARCY :: DATA (penal. bound.)    [OK]"} << endl;
662 
663     \textcolor{comment}{// ----------------- Ext Stress ---------------}
664 
665     \textcolor{keyword}{const} size\_type shiftMapFactor1 =
666             fracture->getMagnificationMapFactor1().size();
667     \textcolor{keyword}{const} size\_type shiftMapFactor2 =
668             fracture->getMagnificationMapFactor2().size();
669 
670     \hyperlink{Core_8h_a4e75b5863535ba1dd79942de2846eff0}{scalarVector\_Type} Bs(shiftVelocity, 0.), coefx(shiftMapFactor1);
671     \hyperlink{Core_8h_a4e75b5863535ba1dd79942de2846eff0}{scalarVector\_Type} coefy(shiftMapFactor2);
672 
673     getfem::generic\_assembly assemb;
674 
675     \textcolor{keywordflow}{if} ( fracture->getMeshFEMVelocity().get\_qdim() == 1 )
676     \{
677         \textcolor{keywordflow}{for} ( size\_type i = 0; i < shiftMapFactor1; ++i )
678         \{
679             coefx [ i ] = 1 / fracture->getMagnificationMapFactor1(i);
680         \}
681         assemb.set(\textcolor{stringliteral}{"p=data$1(#2);"}
682             \textcolor{stringliteral}{"V(#1)+=-comp(vBase(#1).Base(#2))"}
683             \textcolor{stringliteral}{"(:,1, h).p(h)"});
684     \}
685     \textcolor{keywordflow}{else}
686     \{
687 
688         \textcolor{comment}{//attenzione, quando integro sulla frattura devo tenere conto che quella vera non è flat quindi le
       lunghezze/aree devono essere convertite}
689         \textcolor{keywordflow}{for} ( size\_type i = 0; i < shiftMapFactor1; ++i )
690         \{
691             coefx [ i ] = 1 / fracture->getMagnificationMapFactor1(i);
692             coefy [ i ] = 1 / fracture->getMagnificationMapFactor2(i);
693         \}
694         assemb.set(\textcolor{stringliteral}{"p=data$1(#2);"}
695             \textcolor{stringliteral}{"V(#1)+=-comp(vBase(#1).Normal().Base(#2))"}
696             \textcolor{stringliteral}{"(:,k, k, h).p(h)"});
697     \}
698 
699     \textcolor{comment}{// Assign the M\_mediumMesh integration method}
700     assemb.push\_mi(fracture->getIntegrationMethodVelocity());
701 
702     \textcolor{comment}{// Assign the M\_mediumMesh finite element space}
703     assemb.push\_mf(fracture->getMeshFEMVelocity());
704 
705     \textcolor{comment}{// Assign the M\_mediumMesh finite element space for the coefficients}
706     assemb.push\_mf(bcHandler->getFractureBC(fracture->getId())->getMeshFEM());
707 
708     \textcolor{comment}{// Assign the coefficients}
709     assemb.push\_data(*Pneumann);
710 
711     \textcolor{comment}{// Set the vector to save the evaluations}
712     assemb.push\_vec(Bs);
713 
714     \textcolor{comment}{// Assemble in each sub region}
715     \textcolor{keyword}{const} size\_type shiftNeumann =
716             bcHandler->getFractureBC(fractureID)->getNeumann().size();
717     \textcolor{keywordflow}{for} ( size\_type bndID = 0; bndID < shiftNeumann; bndID++ )
718     \{
719         \textcolor{keyword}{const} size\_type val = bcHandler->getFractureBC(fractureID)->getNeumann( bndID);
720         assemb.assembly( fracture->getMeshFEMVelocity().linked\_mesh().get\_mpi\_sub\_region( val ));
721     \}
722 
723     \textcolor{keywordflow}{for} ( size\_type i = 0; i < shiftVelocity; ++i )
724     \{
725         (*Bstress) [ i ] = Bs [ i ];
726     \}
727 
728 \} \textcolor{comment}{// darcy\_dataF}
\end{DoxyCode}
\hypertarget{namespacegetfem_a41dedc9759949101293821b324cf5ac6}{\index{getfem@{getfem}!velocity\-Jump\-\_\-\-Bifurcation@{velocity\-Jump\-\_\-\-Bifurcation}}
\index{velocity\-Jump\-\_\-\-Bifurcation@{velocity\-Jump\-\_\-\-Bifurcation}!getfem@{getfem}}
\subsubsection[{velocity\-Jump\-\_\-\-Bifurcation}]{\setlength{\rightskip}{0pt plus 5cm}void getfem\-::velocity\-Jump\-\_\-\-Bifurcation (
\begin{DoxyParamCaption}
\item[{{\bf sparse\-Matrix\-Ptr\-\_\-\-Type} \&}]{M, }
\item[{const {\bf Fracture\-Handler\-Ptr\-\_\-\-Type} \&}]{fracture, }
\item[{const {\bf Fracture\-Handler\-Ptr\-\_\-\-Type} \&}]{other\-Fracture, }
\item[{const size\-\_\-type \&}]{convex}
\end{DoxyParamCaption}
)}}\label{namespacegetfem_a41dedc9759949101293821b324cf5ac6}

\begin{DoxyCode}
1025 \{
1026 
1027     \textcolor{keyword}{const} size\_type shiftVelocity = fracture->getMeshFEMVelocity().nb\_dof();
1028     \hyperlink{Core_8h_a4e75b5863535ba1dd79942de2846eff0}{scalarVector\_Type} V ( shiftVelocity, 0. );
1029 
1030     \textcolor{keyword}{const} size\_type otherFractureId = otherFracture->getId();
1031     \hyperlink{LevelSetHandler_8h_aba343569cb3213c103252f69c39cad0b}{LevelSetHandlerPtr\_Type}& levelSetOtherFracture = otherFracture->getLevelSet();
1032 
1033     \textcolor{keyword}{const} getfem::pintegration\_method intTypeIM = getfem::int\_method\_descriptor ( \textcolor{stringliteral}{"IM\_GAUSS1D(3)"} );
1034     getfem::mesh\_im\_level\_set meshImLevel ( *fracture->getMeshLevelSetIntersect ( otherFractureId ), 
      getfem::mesh\_im\_level\_set::INTEGRATE\_BOUNDARY );
1035 
1036     meshImLevel.set\_integration\_method ( fracture->getMeshFlat().convex\_index(), intTypeIM );
1037 
1038     meshImLevel.set\_simplex\_im ( intTypeIM );
1039 
1040     getfem::mesh\_region meshElement;
1041     meshElement.add ( convex );
1042 
1043     generic\_assembly assem;
1044 
1045     
1046     
1047     
1048     
1049     
1050     
1051     
1052 \}\textcolor{comment}{// velocutyJump\_Bifurcation}
\end{DoxyCode}
\hypertarget{namespacegetfem_acc74b86734c3814042e614d015f23876}{\index{getfem@{getfem}!velocity\-Jump\-\_\-\-Cross@{velocity\-Jump\-\_\-\-Cross}}
\index{velocity\-Jump\-\_\-\-Cross@{velocity\-Jump\-\_\-\-Cross}!getfem@{getfem}}
\subsubsection[{velocity\-Jump\-\_\-\-Cross}]{\setlength{\rightskip}{0pt plus 5cm}void getfem\-::velocity\-Jump\-\_\-\-Cross (
\begin{DoxyParamCaption}
\item[{{\bf sparse\-Matrix\-Ptr\-\_\-\-Type} \&}]{M, }
\item[{const {\bf Fracture\-Handler\-Ptr\-\_\-\-Type} \&}]{fracture, }
\item[{const {\bf Fracture\-Handler\-Ptr\-\_\-\-Type} \&}]{other\-Fracture, }
\item[{const size\-\_\-type \&}]{convex}
\end{DoxyParamCaption}
)}}\label{namespacegetfem_acc74b86734c3814042e614d015f23876}

\begin{DoxyCode}
946 \{
947     \textcolor{keyword}{const} size\_type shiftVelocity = fracture->getMeshFEMVelocity().nb\_dof();
948     \hyperlink{Core_8h_a4e75b5863535ba1dd79942de2846eff0}{scalarVector\_Type} V ( shiftVelocity, 0. );
949 
950     \textcolor{keyword}{const} size\_type otherFractureId = otherFracture->getId();
951     \hyperlink{LevelSetHandler_8h_aba343569cb3213c103252f69c39cad0b}{LevelSetHandlerPtr\_Type}& levelSetOtherFracture = otherFracture->getLevelSet();
952 
953     \textcolor{keyword}{const} getfem::pintegration\_method intTypeIM = getfem::int\_method\_descriptor ( \textcolor{stringliteral}{"IM\_GAUSS1D(3)"} );
954     getfem::mesh\_im\_level\_set meshImLevel ( *fracture->getMeshLevelSetIntersect ( otherFractureId ),
955                                             getfem::mesh\_im\_level\_set::INTEGRATE\_BOUNDARY );
956 
957     meshImLevel.set\_integration\_method ( fracture->getMeshFlat().convex\_index(), intTypeIM );
958 
959     meshImLevel.set\_simplex\_im ( intTypeIM );
960 
961     getfem::mesh\_region meshElement;
962     meshElement.add ( convex );
963 
964     generic\_assembly assem;
965 
966     assem.set ( \textcolor{stringliteral}{"V(#1)+=comp(vBase(#1).NonLin(#2))"}
967                 \textcolor{stringliteral}{"(:,1,1)"} );
968 
969     level\_set\_unit\_normal nterm ( fracture->getMeshLevelSetIntersect ( otherFractureId )->get\_level\_set(0)
      ->get\_mesh\_fem(),
970                                   fracture->getMeshLevelSetIntersect ( otherFractureId )->get\_level\_set(0)
      ->values() );
971 
972     assem.push\_mi ( meshImLevel );
973 
974     \textcolor{comment}{// Assign the mesh finite element space}
975     assem.push\_mf ( fracture->getMeshFEMVelocity() );
976 
977     \textcolor{comment}{// Assign the mesh finite element space for the coefficients}
978     assem.push\_mf ( fracture->getMeshLevelSetIntersect ( otherFractureId )->get\_level\_set(0)->get\_mesh\_fem(
      ) );
979 
980     \textcolor{comment}{// Assign the non linear term}
981     assem.push\_nonlinear\_term ( &nterm );
982 
983     \textcolor{comment}{// Set the matrices to save the evaluations}
984     assem.push\_vec ( V );
985 
986     assem.assembly ( meshElement );
987 
988     \textcolor{keyword}{const} \hyperlink{Core_8h_a83c51913d041a5001e8683434c09857f}{sizeVector\_Type}& extendedVelocity = fracture->getExtendedVelocity();
989     \textcolor{keyword}{const} size\_type extendedNumVelocity = fracture->getNumExtendedVelocity();
990 
991     \textcolor{keywordflow}{for} ( size\_type i = 0; i < extendedNumVelocity; ++i )
992     \{
993         \textcolor{keyword}{const} size\_type ii = extendedVelocity [ i ];
994         \textcolor{keyword}{const} base\_node pointFlat = fracture->getMeshFEMVelocity().point\_of\_basic\_dof(ii);
995         base\_node pointMapped(0,0);
996         base\_node pointMapped1(0,0);
997     scalar\_type t = ii*1./(fracture->getData().getSpatialDiscretization () );
998         pointMapped[0] = t;
999         pointMapped1[0] = pointFlat[0];
1000         pointMapped1[1] = fracture->getLevelSet()->getData()->y\_map( pointMapped );
1001 
1002     \textcolor{keyword}{const} scalar\_type levelSetValue = levelSetOtherFracture->getData()->ylevelSetFunction ( pointMapped1 );
1003 
1004         \textcolor{keywordflow}{if} ( levelSetValue < 0 )
1005         \{
1006             (*M) ( ii, 0 ) += V [ ii ];
1007             (*M) ( i + shiftVelocity, 0 ) -= V [ ii ];
1008         \}
1009         \textcolor{keywordflow}{else}
1010         \{
1011             (*M) ( ii, 0 ) -= V [ ii ];
1012             (*M) ( i + shiftVelocity, 0 ) += V [ ii ];
1013 
1014         \}
1015 
1016     \}
1017 
1018 \} \textcolor{comment}{// velocityJump\_Cross}
\end{DoxyCode}
